
Features
 * Bulk execute operations from string. basicaly serialize an array of operations so that they can be applied
 * Serialize stream subscriber behaviour for replications
 * Found randomly in transact write item docs: "Nesting Levels have exceeded supported limits."
 * Look through IAmazonDynamoDb comments for any exception descriptions and apply (for example resource not found exception) 
 * Stream error handling
	*// TODO: currently a subscriber will execute once. If it fails, the queue is not
                // blocked and items go directly onto a DLQ. This should be configurable
                // MAKE SURE TO TAKE INTO ACCOUNT DB SYNC CORRUPTION WITH DLQ 
				search for https://docs.aws.amazon.com/lambda/latest/dg/services-dynamodb-errors.html
 * Search for ReturnValuesOnConditionCheckFailure
 * Compiler error message if function is spelled incorrectly isn't great: e.g. try update expression ""SET Attr = if_nost_exists(Attr, :x)""
 * TODO https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ServiceQuotas.html
 * When building a DynamoDBEvent.DynamodbStreamRecord
    * EventVersion is not set
    * If TTL is ever set, the UserIdentity property must be set. It has comments on how

Tests
 * Do a giant fuzz tester of all expressions
 * When scanning and calculating item size, should size be calculated before or after projection

Interface
 * Audit every public facing type/record + document
 * Replicated/distributed/global/synchronized all mean the same thing
 * Audit of C# F# interop
	* + clean up CSharp code
 * full audit of dependencies and dotnet versions
 * Test ``Delete item, with pk, deletes from table and index``. Use to have a look at log indenting, which looks weird inside `applyFilters`
 * make the "you can change this setting" message more consistant
 * audit what has leaked out from the Api.Database into the client. Might need to roll some stuff back there
 * Streamsubscriber.fs: change to an F# interface. Make a separate construct for C#
 
Documentation
 * ScanLimits
 * Everything in Settings.fs
 * SubscriberBehaviour
 * Document model
 * TransactGetItemsAsync, DescribeGlobalTable, ListGlobalTables
 * Docs on locking
    * locking is done at db level (tables and indexes on the same DB are atomic)
    * document locking settings
 * Update table (add replication): copy of data to new table is synchronous
 * Create table stream config, property is not actually used
 * Settings.ClientRequestTokenTTL: extra ducumentation on this one
 * in features.md 
    * output, search for "IsLimitSet". Should not be in there
    * mark deprecated fetch attributes as such with alternative suggestion (e.g. AttributesToGet)
 
Optimisations/refactoring
 * PrecedenceProcessor.fs: Optimize this whole file + Parser.fs they are are a hot path
 * Revisit compiler caching
 * ScanCompiler 
	* List index projections. Allocates a new array for each add (search for AttributeList)
 * Str: asContexted, indentComplex, indent methods. These seem inefficient
 * clean up of test host helpers
 * DistributedDatabaseState.fs: messy needs cleanup
 * AstCompiler
    * Recursion limit still exists: search for ExpressionCompilerRecursionlimit
    * Removed all of the todos about non cached and lazily constructructed things. There are more efficiencies to be found there but they need to be discovered with more logging
 
    